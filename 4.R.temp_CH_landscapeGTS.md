#Fine scale connectivity or Rana temporaria at different spatial scales


Question: what determines connectivity between populations across different spatial scales? 
- same environmental gradient
- Very different landscapes

Important paper on the use of Mantel tests in spatial analyses: Don't!

Legendre et al. 2015 (Mehods in Ecology and Evolution)

http://onlinelibrary.wiley.com/doi/10.1111/2041-210X.12425/epdf

I'm interested in the at-site and between-site variables that could determine connectivity between populations. 

###Part 1. Connectivity will be determined by at and between site variables, rather than absolute distance. For between site, I hypothesise that topographic complexity with create increased resistance to geneflow. 
a) At site, I hypothesise that site quality i.t.o pond size, and climate i.t.o developmental degree days, will explain migration between ponds. 


###Part 2. Does this hold true at different spatial scales?

Compare Gravity model across all data vs within Structure groups. 

- CHall

- CHS
  CHS.TI
  CHS.VS
 
- CHN

- CZ
 
Major barriers to dispersal? Ridges? How will I define this? 
Monmoniers algorithm 

###Part 3. Can I identify the range edge? I hypothesis that the range edge is determined by limited developmental time for the tadpoles. ie. duration of snow cover (snow free days), or developmental degree days. 

This will be estimated by bottleneck signatures: 

excess heterozygosity

Fis

nucleotide diversity

H0: Range edge is associated with season length -> 

mean temp of laying date: lower = range edge (- correlation)

degree days: less = range edge (-correlation)

Shadow days: more = range edge 




#####Part 1: Gravity Model

As implemented in Murphy et al. 2010. 

They've just released an R package: GeNetIt

https://cran.r-project.org/web/packages/GeNetIt/GeNetIt.pdf

1. Build a network of all connections 

2. Test the best fit model (i.e. which variables best describe the genetic distance)

3. Compare to a smaller network (e.g. 10km - double the dispersal distance of R.temp)


Building the network in R
```
library(sp)

setwd("/Users/alexjvr/2016RADAnalysis/3_LandscapeGenetics/")

rtemp_sites <- read.csv("rtemp_sites.csv", header=T)

xy <- cbind(rtemp_site$lat, rtemp_site$long)  ##create a df with only the coordinates

pts <- SpatialPoints(xy)  ##turns them into spatial points for sp

Rtemp.Spatial <- SpatialPointsDataFrame(pts, rtemp_site)  ##create a SpatialPointsDF. This is needed to create the network below. 


###Creating the network
library(GeNetIt)

sat.graph.rtemp <- knn.graph(Rtemp.Spatial, row.names=Rtemp.Spatial@data[,"site"], long.lat=T) #saturated graph
graph.rtemp.10km <- knn.graph(Rtemp.Spatial, row.names=Rtemp.Spatial@data[,"site"], long.lat=T, max.dist=10)  ##long.lat=T for decimal degrees. 

##plot
par(mfrow=c(3,2)) ##creates box for two plots. c(3,2) means 3 rows, 2 columns

plot(sat.graph.rtemp.30km, col="grey")
points(Rtemp.Spatial, co="red", pch=20, cex=0.5)
box()
title("30km dist contrained")

plot(sat.graph.rtemp, col="grey")
points(Rtemp.Spatial, co="red", pch=20, cex=0.5)
box()
title("Saturated graph")

```

![alt_txt][Sat.graphs]
[Sat.graphs]:https://cloud.githubusercontent.com/assets/12142475/19343990/c140a4f2-9138-11e6-818f-c078e047b125.png



Between site landscape variables (c) have been obtained already by Josh. These are just along a line - measuring the proportion of different variables, and the nr of times crossing linear variables (e.g. roads, rivers, etc). 


At site variables (v) would include landscape and climate. 

Landscape was extracted for 4 buffers surrounding the ponds (0-200m, 201-500m, 501-1000, 1001-2000). Units = proportion of area covered. For linear objects, the km linear obj/km2 measured. 

I will calculate the correlation of each landscape variables within the different buffers: 

##Plan: 

Gravity model on each canton: 

This stays within the 30km distance limit for which Josh extracted data. And it makes sense according to the IBD plots. It seems like VS populations, all within 40km from each other, show no IBD pattern. 

1. Ticino

2. VS

3. Bern

4. EAST

This way I can compare between each canton, and also validate the model throughout Switzerland 

##Data

w: distance between sites (calculated using great circle distance)

c: between site variables

v: at site variables




##Test Data1: Ticino

I will set up the protocol and test the method using Canton Ticino. 

16 populations

7-20 individuals per population


Import Data1 CHall into R and subset to have only Ticino populations: 

```
library(adegenet)
library(hierfstat)
```




###Part3: Range Edge

As a proxy for pop size, we can use the number of clutches that I counted at each pond. 

Compare this to the calculated Hs. 

```
##Read in data and create plots

Table1 <- read.table("Table1.sumstats", header=T)
muTable1$names <- factor(Table1$names, level=Table1$names)

q.Hs <- qplot(names, Hs, fill=factor((elev.level), levels=c("Low", "Mid", "High")), data=Table1, geom="boxplot") + scale_fill_manual(values=c("yellow","green","blue"))+theme_bw()+theme(legend.title=element_blank()) + theme(axis.text.x=element_blank(), axis.title.x=element_blank()) 

q.clutch <- qplot(names, Nr.clutches, fill=factor((elev.level), levels=c("Low", "Mid", "High")), data=Table1, geom="boxplot") + scale_fill_manual(values=c("yellow","green","blue"))+theme_bw()+theme(legend.title=element_blank()) + theme(axis.text.x=element_text(angle = 90, hjust = 0))

multiplot(q.clutch, q.Hs)

```

![alt_txt][Hs.clutch]
[Hs.clutch]:


```
###Function for multiplot in ggplot2
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}
```




